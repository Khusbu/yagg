! function(modules) {
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: !1
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.loaded = !0, module.exports
    }
    var installedModules = {};
    return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.p = "", __webpack_require__(0)
}([function(module, exports, __webpack_require__) {
    (function(global) {
        ! function() {
            function Diff2Html() {}
            var diffParser = __webpack_require__(1).DiffParser,
                fileLister = __webpack_require__(3).FileListPrinter,
                htmlPrinter = __webpack_require__(21).HtmlPrinter;
            Diff2Html.prototype.getJsonFromDiff = function(diffInput) {
                return diffParser.generateDiffJson(diffInput)
            }, Diff2Html.prototype.getPrettyHtml = function(diffInput, config) {
                var configOrEmpty = config || {},
                    diffJson = diffInput;
                configOrEmpty.inputFormat && "diff" !== configOrEmpty.inputFormat || (diffJson = diffParser.generateDiffJson(diffInput));
                var fileList = "";
                configOrEmpty.showFiles === !0 && (fileList = fileLister.generateFileList(diffJson, configOrEmpty));
                var diffOutput = "";
                return diffOutput = "side-by-side" === configOrEmpty.outputFormat ? htmlPrinter.generateSideBySideJsonHtml(diffJson, configOrEmpty) : htmlPrinter.generateLineByLineJsonHtml(diffJson, configOrEmpty), fileList + diffOutput
            }, Diff2Html.prototype.getPrettyHtmlFromDiff = function(diffInput, config) {
                var configOrEmpty = config || {};
                return configOrEmpty.inputFormat = "diff", configOrEmpty.outputFormat = "line-by-line", this.getPrettyHtml(diffInput, configOrEmpty)
            }, Diff2Html.prototype.getPrettyHtmlFromJson = function(diffJson, config) {
                var configOrEmpty = config || {};
                return configOrEmpty.inputFormat = "json", configOrEmpty.outputFormat = "line-by-line", this.getPrettyHtml(diffJson, configOrEmpty)
            }, Diff2Html.prototype.getPrettySideBySideHtmlFromDiff = function(diffInput, config) {
                var configOrEmpty = config || {};
                return configOrEmpty.inputFormat = "diff", configOrEmpty.outputFormat = "side-by-side", this.getPrettyHtml(diffInput, configOrEmpty)
            }, Diff2Html.prototype.getPrettySideBySideHtmlFromJson = function(diffJson, config) {
                var configOrEmpty = config || {};
                return configOrEmpty.inputFormat = "json", configOrEmpty.outputFormat = "side-by-side", this.getPrettyHtml(diffJson, configOrEmpty)
            };
            var diffObject = new Diff2Html;
            module.exports.Diff2Html = diffObject, global.Diff2Html = diffObject
        }()
    }).call(exports, function() {
        return this
    }())
}, function(module, exports, __webpack_require__) {
    ! function() {
        function DiffParser() {}

        function getExtension(filename, language) {
            var nameSplit = filename.split(".");
            return nameSplit.length > 1 ? nameSplit[nameSplit.length - 1] : language
        }
        var utils = __webpack_require__(2).Utils,
            LINE_TYPE = {
                INSERTS: "d2h-ins",
                DELETES: "d2h-del",
                INSERT_CHANGES: "d2h-ins d2h-change",
                DELETE_CHANGES: "d2h-del d2h-change",
                CONTEXT: "d2h-cntx",
                INFO: "d2h-info"
            };
        DiffParser.prototype.LINE_TYPE = LINE_TYPE, DiffParser.prototype.generateDiffJson = function(diffInput) {
            var files = [],
                currentFile = null,
                currentBlock = null,
                oldLine = null,
                newLine = null,
                saveBlock = function() {
                    currentBlock && (currentFile.blocks.push(currentBlock), currentBlock = null)
                },
                saveFile = function() {
                    currentFile && currentFile.newName && (files.push(currentFile), currentFile = null)
                },
                startFile = function() {
                    saveBlock(), saveFile(), currentFile = {}, currentFile.blocks = [], currentFile.deletedLines = 0, currentFile.addedLines = 0
                },
                startBlock = function(line) {
                    saveBlock();
                    var values;
                    (values = /^@@ -(\d+),\d+ \+(\d+),\d+ @@.*/.exec(line)) ? currentFile.isCombined = !1: (values = /^@@@ -(\d+),\d+ -\d+,\d+ \+(\d+),\d+ @@@.*/.exec(line)) ? currentFile.isCombined = !0 : (values = [0, 0], currentFile.isCombined = !1), oldLine = values[1], newLine = values[2], currentBlock = {}, currentBlock.lines = [], currentBlock.oldStartLine = oldLine, currentBlock.newStartLine = newLine, currentBlock.header = line
                },
                createLine = function(line) {
                    var currentLine = {};
                    currentLine.content = line;
                    var newLinePrefixes = currentFile.isCombined ? ["+", " +"] : ["+"],
                        delLinePrefixes = currentFile.isCombined ? ["-", " -"] : ["-"];
                    utils.startsWith(line, newLinePrefixes) ? (currentFile.addedLines++, currentLine.type = LINE_TYPE.INSERTS, currentLine.oldNumber = null, currentLine.newNumber = newLine++, currentBlock.lines.push(currentLine)) : utils.startsWith(line, delLinePrefixes) ? (currentFile.deletedLines++, currentLine.type = LINE_TYPE.DELETES, currentLine.oldNumber = oldLine++, currentLine.newNumber = null, currentBlock.lines.push(currentLine)) : (currentLine.type = LINE_TYPE.CONTEXT, currentLine.oldNumber = oldLine++, currentLine.newNumber = newLine++, currentBlock.lines.push(currentLine))
                },
                diffLines = diffInput.split("\n"),
                oldMode = /^old mode (\d{6})/,
                newMode = /^new mode (\d{6})/,
                deletedFileMode = /^deleted file mode (\d{6})/,
                newFileMode = /^new file mode (\d{6})/,
                copyFrom = /^copy from (.+)/,
                copyTo = /^copy to (.+)/,
                renameFrom = /^rename from (.+)/,
                renameTo = /^rename to (.+)/,
                similarityIndex = /^similarity index (\d+)%/,
                dissimilarityIndex = /^dissimilarity index (\d+)%/,
                index = /^index ([0-9a-z]+)..([0-9a-z]+) (\d{6})?/,
                combinedIndex = /^index ([0-9a-z]+),([0-9a-z]+)..([0-9a-z]+)/,
                combinedMode = /^mode (\d{6}),(\d{6})..(\d{6})/,
                combinedNewFile = /^new file mode (\d{6})/,
                combinedDeletedFile = /^deleted file mode (\d{6}),(\d{6})/;
            return diffLines.forEach(function(line) {
                if (line && !utils.startsWith(line, "*")) {
                    var values = [];
                    utils.startsWith(line, "diff") ? startFile() : currentFile && !currentFile.oldName && (values = /^--- [aiwco]\/(.+)$/.exec(line)) ? (currentFile.oldName = values[1], currentFile.language = getExtension(currentFile.oldName, currentFile.language)) : currentFile && !currentFile.newName && (values = /^\+\+\+ [biwco]?\/(.+)$/.exec(line)) ? (currentFile.newName = values[1], currentFile.language = getExtension(currentFile.newName, currentFile.language)) : currentFile && utils.startsWith(line, "@@") ? startBlock(line) : (values = oldMode.exec(line)) ? currentFile.oldMode = values[1] : (values = newMode.exec(line)) ? currentFile.newMode = values[1] : (values = deletedFileMode.exec(line)) ? currentFile.deletedFileMode = values[1] : (values = newFileMode.exec(line)) ? currentFile.newFileMode = values[1] : (values = copyFrom.exec(line)) ? (currentFile.oldName = values[1], currentFile.isCopy = !0) : (values = copyTo.exec(line)) ? (currentFile.newName = values[1], currentFile.isCopy = !0) : (values = renameFrom.exec(line)) ? (currentFile.oldName = values[1], currentFile.isRename = !0) : (values = renameTo.exec(line)) ? (currentFile.newName = values[1], currentFile.isRename = !0) : (values = similarityIndex.exec(line)) ? currentFile.unchangedPercentage = values[1] : (values = dissimilarityIndex.exec(line)) ? currentFile.changedPercentage = values[1] : (values = index.exec(line)) ? (currentFile.checksumBefore = values[1], currentFile.checksumAfter = values[2], values[2] && (currentFile.mode = values[3])) : (values = combinedIndex.exec(line)) ? (currentFile.checksumBefore = [values[2], values[3]], currentFile.checksumAfter = values[1]) : (values = combinedMode.exec(line)) ? (currentFile.oldMode = [values[2], values[3]], currentFile.newMode = values[1]) : (values = combinedNewFile.exec(line)) ? currentFile.newFileMode = values[1] : (values = combinedDeletedFile.exec(line)) ? currentFile.deletedFileMode = values[1] : currentBlock && createLine(line)
                }
            }), saveBlock(), saveFile(), files
        }, module.exports.DiffParser = new DiffParser
    }()
}, function(module) {
    ! function() {
        function Utils() {}
        Utils.prototype.escape = function(str) {
            return str.slice(0).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\t/g, "    ")
        }, Utils.prototype.getRandomId = function(prefix) {
            return prefix + "-" + Math.random().toString(36).slice(-3)
        }, Utils.prototype.startsWith = function(str, start) {
            if ("object" == typeof start) {
                var result = !1;
                return start.forEach(function(s) {
                    0 === str.indexOf(s) && (result = !0)
                }), result
            }
            return 0 === str.indexOf(start)
        }, Utils.prototype.valueOrEmpty = function(value) {
            return value ? value : ""
        }, module.exports.Utils = new Utils
    }()
}, function(module, exports, __webpack_require__) {
    ! function() {
        function FileListPrinter() {}
        var printerUtils = __webpack_require__(4).PrinterUtils,
            utils = __webpack_require__(2).Utils;
        FileListPrinter.prototype.generateFileList = function(diffFiles) {
            var hideId = utils.getRandomId("d2h-hide"),
                showId = utils.getRandomId("d2h-show");
            return '<div class="d2h-file-list-wrapper">\n      <a id="' + hideId + '" class="d2h-hide" href="#' + hideId + '"></a>\n     <a id="' + showId + 'd2h-show" class="d2h-show" href="#' + showId + '">-</a>\n     <div class="d2h-clear"></div>\n     <table class="d2h-file-list">\n' + diffFiles.map(function(file) {
                return '     <tr class="d2h-file-list-line">\n       <td class="d2h-lines-added">\n         <span>+' + file.addedLines + '</span>\n       </td>\n       <td class="d2h-lines-deleted">\n         <span>-' + file.deletedLines + '</span>\n       </td>\n       <td class="d2h-file-name"><a href="#' + printerUtils.getHtmlId(file) + '">&nbsp;' + printerUtils.getDiffName(file) + "</a></td>\n     </tr>\n"
            }).join("\n") + "</table></div>\n"
        }, module.exports.FileListPrinter = new FileListPrinter
    }()
}, function(module, exports, __webpack_require__) {
    ! function() {
        function PrinterUtils() {}

        function isDeletedName(name) {
            return "dev/null" === name
        }

        function removeIns(line) {
            return line.replace(/(<ins[^>]*>((.|\n)*?)<\/ins>)/g, "")
        }

        function removeDel(line) {
            return line.replace(/(<del[^>]*>((.|\n)*?)<\/del>)/g, "")
        }
        var jsDiff = __webpack_require__(5),
            utils = __webpack_require__(2).Utils,
            Rematch = __webpack_require__(20).Rematch;
        PrinterUtils.prototype.getHtmlId = function(file) {
            var hashCode = function(text) {
                var i, chr, len, hash = 0;
                if (0 === text.length) return hash;
                for (i = 0, len = text.length; len > i; i++) chr = text.charCodeAt(i), hash = (hash << 5) - hash + chr, hash |= 0;
                return hash
            };
            return "d2h-" + hashCode(this.getDiffName(file)).toString().slice(-6)
        }, PrinterUtils.prototype.getDiffName = function(file) {
            var oldFilename = file.oldName,
                newFilename = file.newName;
            return oldFilename && newFilename && oldFilename !== newFilename && !isDeletedName(newFilename) ? oldFilename + " -> " + newFilename : newFilename && !isDeletedName(newFilename) ? newFilename : oldFilename ? oldFilename : "Unknown filename"
        }, PrinterUtils.prototype.diffHighlight = function(diffLine1, diffLine2, config) {
            var linePrefix1, linePrefix2, unprefixedLine1, unprefixedLine2, prefixSize = 1;
            config.isCombined && (prefixSize = 2), linePrefix1 = diffLine1.substr(0, prefixSize), linePrefix2 = diffLine2.substr(0, prefixSize), unprefixedLine1 = diffLine1.substr(prefixSize), unprefixedLine2 = diffLine2.substr(prefixSize);
            var diff;
            diff = config.charByChar ? jsDiff.diffChars(unprefixedLine1, unprefixedLine2) : jsDiff.diffWordsWithSpace(unprefixedLine1, unprefixedLine2);
            var highlightedLine = "",
                changedWords = [];
            if (!config.charByChar && "words" === config.matching) {
                var treshold = .25;
                "undefined" != typeof config.matchWordsThreshold && (treshold = config.matchWordsThreshold);
                var matcher = Rematch.rematch(function(a, b) {
                        var amod = a.value,
                            bmod = b.value;
                        return Rematch.distance(amod, bmod)
                    }),
                    removed = diff.filter(function(element) {
                        return element.removed
                    }),
                    added = diff.filter(function(element) {
                        return element.added
                    }),
                    chunks = matcher(added, removed);
                chunks.forEach(function(chunk) {
                    if (1 === chunk[0].length && 1 === chunk[1].length) {
                        var dist = Rematch.distance(chunk[0][0].value, chunk[1][0].value);
                        treshold > dist && (changedWords.push(chunk[0][0]), changedWords.push(chunk[1][0]))
                    }
                })
            }
            return diff.forEach(function(part) {
                var addClass = changedWords.indexOf(part) > -1 ? ' class="d2h-change"' : "",
                    elemType = part.added ? "ins" : part.removed ? "del" : null,
                    escapedValue = utils.escape(part.value);
                highlightedLine += null !== elemType ? "<" + elemType + addClass + ">" + escapedValue + "</" + elemType + ">" : escapedValue
            }), {
                first: {
                    prefix: linePrefix1,
                    line: removeIns(highlightedLine)
                },
                second: {
                    prefix: linePrefix2,
                    line: removeDel(highlightedLine)
                }
            }
        }, module.exports.PrinterUtils = new PrinterUtils
    }()
}, function(module, exports, __webpack_require__) {
    "use strict";

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            "default": obj
        }
    }
    exports.__esModule = !0;
    var _diffBase = __webpack_require__(6),
        _diffBase2 = _interopRequireDefault(_diffBase),
        _diffCharacter = __webpack_require__(7),
        _diffWord = __webpack_require__(8),
        _diffLine = __webpack_require__(10),
        _diffSentence = __webpack_require__(11),
        _diffCss = __webpack_require__(12),
        _diffJson = __webpack_require__(13),
        _patchApply = __webpack_require__(14),
        _patchParse = __webpack_require__(15),
        _patchCreate = __webpack_require__(17),
        _convertDmp = __webpack_require__(18),
        _convertXml = __webpack_require__(19);
    exports.Diff = _diffBase2["default"], exports.diffChars = _diffCharacter.diffChars, exports.diffWords = _diffWord.diffWords, exports.diffWordsWithSpace = _diffWord.diffWordsWithSpace, exports.diffLines = _diffLine.diffLines, exports.diffTrimmedLines = _diffLine.diffTrimmedLines, exports.diffSentences = _diffSentence.diffSentences, exports.diffCss = _diffCss.diffCss, exports.diffJson = _diffJson.diffJson, exports.structuredPatch = _patchCreate.structuredPatch, exports.createTwoFilesPatch = _patchCreate.createTwoFilesPatch, exports.createPatch = _patchCreate.createPatch, exports.applyPatch = _patchApply.applyPatch, exports.applyPatches = _patchApply.applyPatches, exports.parsePatch = _patchParse.parsePatch, exports.convertChangesToDMP = _convertDmp.convertChangesToDMP, exports.convertChangesToXML = _convertXml.convertChangesToXML, exports.canonicalize = _diffJson.canonicalize
}, function(module, exports) {
    "use strict";

    function Diff() {}

    function buildValues(diff, components, newString, oldString, useLongestToken) {
        for (var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0; componentLen > componentPos; componentPos++) {
            var component = components[componentPos];
            if (component.removed) {
                if (component.value = oldString.slice(oldPos, oldPos + component.count).join(""), oldPos += component.count, componentPos && components[componentPos - 1].added) {
                    var tmp = components[componentPos - 1];
                    components[componentPos - 1] = components[componentPos], components[componentPos] = tmp
                }
            } else {
                if (!component.added && useLongestToken) {
                    var value = newString.slice(newPos, newPos + component.count);
                    value = value.map(function(value, i) {
                        var oldValue = oldString[oldPos + i];
                        return oldValue.length > value.length ? oldValue : value
                    }), component.value = value.join("")
                } else component.value = newString.slice(newPos, newPos + component.count).join("");
                newPos += component.count, component.added || (oldPos += component.count)
            }
        }
        var lastComponent = components[componentLen - 1];
        return (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value) && (components[componentLen - 2].value += lastComponent.value, components.pop()), components
    }

    function clonePath(path) {
        return {
            newPos: path.newPos,
            components: path.components.slice(0)
        }
    }
    exports.__esModule = !0, exports["default"] = Diff, Diff.prototype = {
        diff: function(oldString, newString) {
            function done(value) {
                return callback ? (setTimeout(function() {
                    callback(void 0, value)
                }, 0), !0) : value
            }

            function execEditLength() {
                for (var diagonalPath = -1 * editLength; editLength >= diagonalPath; diagonalPath += 2) {
                    var basePath = void 0,
                        addPath = bestPath[diagonalPath - 1],
                        removePath = bestPath[diagonalPath + 1],
                        _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
                    addPath && (bestPath[diagonalPath - 1] = void 0);
                    var canAdd = addPath && addPath.newPos + 1 < newLen,
                        canRemove = removePath && _oldPos >= 0 && oldLen > _oldPos;
                    if (canAdd || canRemove) {
                        if (!canAdd || canRemove && addPath.newPos < removePath.newPos ? (basePath = clonePath(removePath), self.pushComponent(basePath.components, void 0, !0)) : (basePath = addPath, basePath.newPos++, self.pushComponent(basePath.components, !0, void 0)), _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath), basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
                        bestPath[diagonalPath] = basePath
                    } else bestPath[diagonalPath] = void 0
                }
                editLength++
            }
            var options = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2],
                callback = options.callback;
            "function" == typeof options && (callback = options, options = {}), this.options = options;
            var self = this;
            oldString = this.castInput(oldString), newString = this.castInput(newString), oldString = this.removeEmpty(this.tokenize(oldString)), newString = this.removeEmpty(this.tokenize(newString));
            var newLen = newString.length,
                oldLen = oldString.length,
                editLength = 1,
                maxEditLength = newLen + oldLen,
                bestPath = [{
                    newPos: -1,
                    components: []
                }],
                oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
            if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) return done([{
                value: newString.join(""),
                count: newString.length
            }]);
            if (callback) ! function exec() {
                setTimeout(function() {
                    return editLength > maxEditLength ? callback() : void(execEditLength() || exec())
                }, 0)
            }();
            else
                for (; maxEditLength >= editLength;) {
                    var ret = execEditLength();
                    if (ret) return ret
                }
        },
        pushComponent: function(components, added, removed) {
            var last = components[components.length - 1];
            last && last.added === added && last.removed === removed ? components[components.length - 1] = {
                count: last.count + 1,
                added: added,
                removed: removed
            } : components.push({
                count: 1,
                added: added,
                removed: removed
            })
        },
        extractCommon: function(basePath, newString, oldString, diagonalPath) {
            for (var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0; newLen > newPos + 1 && oldLen > oldPos + 1 && this.equals(newString[newPos + 1], oldString[oldPos + 1]);) newPos++, oldPos++, commonCount++;
            return commonCount && basePath.components.push({
                count: commonCount
            }), basePath.newPos = newPos, oldPos
        },
        equals: function(left, right) {
            return left === right
        },
        removeEmpty: function(array) {
            for (var ret = [], i = 0; i < array.length; i++) array[i] && ret.push(array[i]);
            return ret
        },
        castInput: function(value) {
            return value
        },
        tokenize: function(value) {
            return value.split("")
        }
    }, module.exports = exports["default"]
}, function(module, exports, __webpack_require__) {
    "use strict";

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            "default": obj
        }
    }

    function diffChars(oldStr, newStr, callback) {
        return characterDiff.diff(oldStr, newStr, callback)
    }
    exports.__esModule = !0, exports.diffChars = diffChars;
    var _base = __webpack_require__(6),
        _base2 = _interopRequireDefault(_base),
        characterDiff = new _base2["default"];
    exports.characterDiff = characterDiff
}, function(module, exports, __webpack_require__) {
    "use strict";

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            "default": obj
        }
    }

    function diffWords(oldStr, newStr, callback) {
        var options = _utilParams.generateOptions(callback, {
            ignoreWhitespace: !0
        });
        return wordDiff.diff(oldStr, newStr, options)
    }

    function diffWordsWithSpace(oldStr, newStr, callback) {
        return wordDiff.diff(oldStr, newStr, callback)
    }
    exports.__esModule = !0, exports.diffWords = diffWords, exports.diffWordsWithSpace = diffWordsWithSpace;
    var _base = __webpack_require__(6),
        _base2 = _interopRequireDefault(_base),
        _utilParams = __webpack_require__(9),
        extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/,
        reWhitespace = /\S/,
        wordDiff = new _base2["default"];
    exports.wordDiff = wordDiff, wordDiff.equals = function(left, right) {
        return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right)
    }, wordDiff.tokenize = function(value) {
        for (var tokens = value.split(/(\s+|\b)/), i = 0; i < tokens.length - 1; i++) !tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2]) && (tokens[i] += tokens[i + 2], tokens.splice(i + 1, 2), i--);
        return tokens
    }
}, function(module, exports) {
    "use strict";

    function generateOptions(options, defaults) {
        if ("function" == typeof options) defaults.callback = options;
        else if (options)
            for (var _name in options) options.hasOwnProperty(_name) && (defaults[_name] = options[_name]);
        return defaults
    }
    exports.__esModule = !0, exports.generateOptions = generateOptions
}, function(module, exports, __webpack_require__) {
    "use strict";

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            "default": obj
        }
    }

    function diffLines(oldStr, newStr, callback) {
        return lineDiff.diff(oldStr, newStr, callback)
    }

    function diffTrimmedLines(oldStr, newStr, callback) {
        var options = _utilParams.generateOptions(callback, {
            ignoreWhitespace: !0
        });
        return lineDiff.diff(oldStr, newStr, options)
    }
    exports.__esModule = !0, exports.diffLines = diffLines, exports.diffTrimmedLines = diffTrimmedLines;
    var _base = __webpack_require__(6),
        _base2 = _interopRequireDefault(_base),
        _utilParams = __webpack_require__(9),
        lineDiff = new _base2["default"];
    exports.lineDiff = lineDiff, lineDiff.tokenize = function(value) {
        var retLines = [],
            linesAndNewlines = value.split(/(\n|\r\n)/);
        linesAndNewlines[linesAndNewlines.length - 1] || linesAndNewlines.pop();
        for (var i = 0; i < linesAndNewlines.length; i++) {
            var line = linesAndNewlines[i];
            i % 2 && !this.options.newlineIsToken ? retLines[retLines.length - 1] += line : (this.options.ignoreWhitespace && (line = line.trim()), retLines.push(line))
        }
        return retLines
    }
}, function(module, exports, __webpack_require__) {
    "use strict";

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            "default": obj
        }
    }

    function diffSentences(oldStr, newStr, callback) {
        return sentenceDiff.diff(oldStr, newStr, callback)
    }
    exports.__esModule = !0, exports.diffSentences = diffSentences;
    var _base = __webpack_require__(6),
        _base2 = _interopRequireDefault(_base),
        sentenceDiff = new _base2["default"];
    exports.sentenceDiff = sentenceDiff, sentenceDiff.tokenize = function(value) {
        return value.split(/(\S.+?[.!?])(?=\s+|$)/)
    }
}, function(module, exports, __webpack_require__) {
    "use strict";

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            "default": obj
        }
    }

    function diffCss(oldStr, newStr, callback) {
        return cssDiff.diff(oldStr, newStr, callback)
    }
    exports.__esModule = !0, exports.diffCss = diffCss;
    var _base = __webpack_require__(6),
        _base2 = _interopRequireDefault(_base),
        cssDiff = new _base2["default"];
    exports.cssDiff = cssDiff, cssDiff.tokenize = function(value) {
        return value.split(/([{}:;,]|\s+)/)
    }
}, function(module, exports, __webpack_require__) {
    "use strict";

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            "default": obj
        }
    }

    function diffJson(oldObj, newObj, callback) {
        return jsonDiff.diff(oldObj, newObj, callback)
    }

    function canonicalize(obj, stack, replacementStack) {
        stack = stack || [], replacementStack = replacementStack || [];
        var i = void 0;
        for (i = 0; i < stack.length; i += 1)
            if (stack[i] === obj) return replacementStack[i];
        var canonicalizedObj = void 0;
        if ("[object Array]" === objectPrototypeToString.call(obj)) {
            for (stack.push(obj), canonicalizedObj = new Array(obj.length), replacementStack.push(canonicalizedObj), i = 0; i < obj.length; i += 1) canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);
            stack.pop(), replacementStack.pop()
        } else if ("object" == typeof obj && null !== obj) {
            stack.push(obj), canonicalizedObj = {}, replacementStack.push(canonicalizedObj);
            var sortedKeys = [],
                key = void 0;
            for (key in obj) obj.hasOwnProperty(key) && sortedKeys.push(key);
            for (sortedKeys.sort(), i = 0; i < sortedKeys.length; i += 1) key = sortedKeys[i], canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);
            stack.pop(), replacementStack.pop()
        } else canonicalizedObj = obj;
        return canonicalizedObj
    }
    exports.__esModule = !0, exports.diffJson = diffJson, exports.canonicalize = canonicalize;
    var _base = __webpack_require__(6),
        _base2 = _interopRequireDefault(_base),
        _line = __webpack_require__(10),
        objectPrototypeToString = Object.prototype.toString,
        jsonDiff = new _base2["default"];
    exports.jsonDiff = jsonDiff, jsonDiff.useLongestToken = !0, jsonDiff.tokenize = _line.lineDiff.tokenize, jsonDiff.castInput = function(value) {
        return "string" == typeof value ? value : JSON.stringify(canonicalize(value), void 0, "  ")
    }, jsonDiff.equals = function(left, right) {
        return _base2["default"].prototype.equals(left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"))
    }
}, function(module, exports, __webpack_require__) {
    "use strict";

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            "default": obj
        }
    }

    function applyPatch(source, uniDiff) {
        function hunkFits(hunk, toPos) {
            for (var j = 0; j < hunk.lines.length; j++) {
                var line = hunk.lines[j],
                    operation = line[0],
                    content = line.substr(1);
                if (" " === operation || "-" === operation) {
                    if (!compareLine(toPos + 1, lines[toPos], operation, content) && (errorCount++, errorCount > fuzzFactor)) return !1;
                    toPos++
                }
            }
            return !0
        }
        var options = arguments.length <= 2 || void 0 === arguments[2] ? {} : arguments[2];
        if ("string" == typeof uniDiff && (uniDiff = _parse.parsePatch(uniDiff)), Array.isArray(uniDiff)) {
            if (uniDiff.length > 1) throw new Error("applyPatch only works with a single input.");
            uniDiff = uniDiff[0]
        }
        for (var lines = source.split("\n"), hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line, operation, patchContent) {
                return line === patchContent
            }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL = void 0, addEOFNL = void 0, i = 0; i < hunks.length; i++) {
            for (var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1, iterator = _utilDistanceIterator2["default"](toPos, minLine, maxLine); void 0 !== localOffset; localOffset = iterator())
                if (hunkFits(hunk, toPos + localOffset)) {
                    hunk.offset = offset += localOffset;
                    break
                }
            if (void 0 === localOffset) return !1;
            minLine = hunk.offset + hunk.oldStart + hunk.oldLines
        }
        for (var i = 0; i < hunks.length; i++)
            for (var hunk = hunks[i], toPos = hunk.offset + hunk.newStart - 1, j = 0; j < hunk.lines.length; j++) {
                var line = hunk.lines[j],
                    operation = line[0],
                    content = line.substr(1);
                if (" " === operation) toPos++;
                else if ("-" === operation) lines.splice(toPos, 1);
                else if ("+" === operation) lines.splice(toPos, 0, content), toPos++;
                else if ("\\" === operation) {
                    var previousOperation = hunk.lines[j - 1] ? hunk.lines[j - 1][0] : null;
                    "+" === previousOperation ? removeEOFNL = !0 : "-" === previousOperation && (addEOFNL = !0)
                }
            }
        if (removeEOFNL)
            for (; !lines[lines.length - 1];) lines.pop();
        else addEOFNL && lines.push("");
        return lines.join("\n")
    }

    function applyPatches(uniDiff, options) {
        function processIndex() {
            var index = uniDiff[currentIndex++];
            return index ? void options.loadFile(index, function(err, data) {
                if (err) return options.complete(err);
                var updatedContent = applyPatch(data, index, options);
                options.patched(index, updatedContent), setTimeout(processIndex, 0)
            }) : options.complete()
        }
        "string" == typeof uniDiff && (uniDiff = _parse.parsePatch(uniDiff));
        var currentIndex = 0;
        processIndex()
    }
    exports.__esModule = !0, exports.applyPatch = applyPatch, exports.applyPatches = applyPatches;
    var _parse = __webpack_require__(15),
        _utilDistanceIterator = __webpack_require__(16),
        _utilDistanceIterator2 = _interopRequireDefault(_utilDistanceIterator)
}, function(module, exports) {
    "use strict";

    function parsePatch(uniDiff) {
        function parseIndex() {
            var index = {};
            for (list.push(index); i < diffstr.length;) {
                var line = diffstr[i];
                if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) break;
                var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
                header && (index.index = header[1]), i++
            }
            for (parseFileHeader(index), parseFileHeader(index), index.hunks = []; i < diffstr.length;) {
                var line = diffstr[i];
                if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(line)) break;
                if (/^@@/.test(line)) index.hunks.push(parseHunk());
                else {
                    if (line && options.strict) throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(line));
                    i++
                }
            }
        }

        function parseFileHeader(index) {
            var fileHeader = /^(\-\-\-|\+\+\+)\s+(\S+)\s?(.+?)\s*$/.exec(diffstr[i]);
            if (fileHeader) {
                var keyPrefix = "---" === fileHeader[1] ? "old" : "new";
                index[keyPrefix + "FileName"] = fileHeader[2], index[keyPrefix + "Header"] = fileHeader[3], i++
            }
        }

        function parseHunk() {
            for (var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), hunk = {
                    oldStart: +chunkHeader[1],
                    oldLines: +chunkHeader[2] || 1,
                    newStart: +chunkHeader[3],
                    newLines: +chunkHeader[4] || 1,
                    lines: []
                }, addCount = 0, removeCount = 0; i < diffstr.length; i++) {
                var operation = diffstr[i][0];
                if ("+" !== operation && "-" !== operation && " " !== operation && "\\" !== operation) break;
                hunk.lines.push(diffstr[i]), "+" === operation ? addCount++ : "-" === operation ? removeCount++ : " " === operation && (addCount++, removeCount++)
            }
            if (addCount || 1 !== hunk.newLines || (hunk.newLines = 0), removeCount || 1 !== hunk.oldLines || (hunk.oldLines = 0), options.strict) {
                if (addCount !== hunk.newLines) throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
                if (removeCount !== hunk.oldLines) throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1))
            }
            return hunk
        }
        for (var options = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], diffstr = uniDiff.split("\n"), list = [], i = 0; i < diffstr.length;) parseIndex();
        return list
    }
    exports.__esModule = !0, exports.parsePatch = parsePatch
}, function(module, exports) {
    "use strict";
    exports.__esModule = !0, exports["default"] = function(start, minLine, maxLine) {
        var wantForward = !0,
            backwardExhausted = !1,
            forwardExhausted = !1,
            localOffset = 1;
        return function() {
            for (var _again = !0; _again;) {
                if (_again = !1, wantForward && !forwardExhausted) {
                    if (backwardExhausted ? localOffset++ : wantForward = !1, maxLine >= start + localOffset) return localOffset;
                    forwardExhausted = !0
                }
                if (backwardExhausted);
                else {
                    if (forwardExhausted || (wantForward = !0), start - localOffset >= minLine) return -localOffset++;
                    backwardExhausted = !0, _again = !0
                }
            }
        }
    }, module.exports = exports["default"]
}, function(module, exports, __webpack_require__) {
    "use strict";

    function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
            return arr2
        }
        return Array.from(arr)
    }

    function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        function contextLines(lines) {
            return lines.map(function(entry) {
                return " " + entry
            })
        }
        options || (options = {
            context: 4
        });
        var diff = _diffLine.diffLines(oldStr, newStr);
        diff.push({
            value: "",
            lines: []
        });
        for (var hunks = [], oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1, _loop = function(i) {
                var current = diff[i],
                    lines = current.lines || current.value.replace(/\n$/, "").split("\n");
                if (current.lines = lines, current.added || current.removed) {
                    var _curRange;
                    if (!oldRangeStart) {
                        var prev = diff[i - 1];
                        oldRangeStart = oldLine, newRangeStart = newLine, prev && (curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [], oldRangeStart -= curRange.length, newRangeStart -= curRange.length)
                    }(_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
                        return (current.added ? "+" : "-") + entry
                    }))), current.added ? newLine += lines.length : oldLine += lines.length
                } else {
                    if (oldRangeStart)
                        if (lines.length <= 2 * options.context && i < diff.length - 2) {
                            var _curRange2;
                            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)))
                        } else {
                            var _curRange3, contextSize = Math.min(lines.length, options.context);
                            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));
                            var hunk = {
                                oldStart: oldRangeStart,
                                oldLines: oldLine - oldRangeStart + contextSize,
                                newStart: newRangeStart,
                                newLines: newLine - newRangeStart + contextSize,
                                lines: curRange
                            };
                            if (i >= diff.length - 2 && lines.length <= options.context) {
                                var oldEOFNewline = /\n$/.test(oldStr),
                                    newEOFNewline = /\n$/.test(newStr);
                                0 != lines.length || oldEOFNewline ? oldEOFNewline && newEOFNewline || curRange.push("\\ No newline at end of file") : curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file")
                            }
                            hunks.push(hunk), oldRangeStart = 0, newRangeStart = 0, curRange = []
                        }
                    oldLine += lines.length, newLine += lines.length
                }
            }, i = 0; i < diff.length; i++) _loop(i);
        return {
            oldFileName: oldFileName,
            newFileName: newFileName,
            oldHeader: oldHeader,
            newHeader: newHeader,
            hunks: hunks
        }
    }

    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
        var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options),
            ret = [];
        oldFileName == newFileName && ret.push("Index: " + oldFileName), ret.push("==================================================================="), ret.push("--- " + diff.oldFileName + ("undefined" == typeof diff.oldHeader ? "" : "	" + diff.oldHeader)), ret.push("+++ " + diff.newFileName + ("undefined" == typeof diff.newHeader ? "" : "	" + diff.newHeader));
        for (var i = 0; i < diff.hunks.length; i++) {
            var hunk = diff.hunks[i];
            ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@"), ret.push.apply(ret, hunk.lines)
        }
        return ret.join("\n") + "\n"
    }

    function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
        return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options)
    }
    exports.__esModule = !0, exports.structuredPatch = structuredPatch, exports.createTwoFilesPatch = createTwoFilesPatch, exports.createPatch = createPatch;
    var _diffLine = __webpack_require__(10)
}, function(module, exports) {
    "use strict";

    function convertChangesToDMP(changes) {
        for (var ret = [], change = void 0, operation = void 0, i = 0; i < changes.length; i++) change = changes[i], operation = change.added ? 1 : change.removed ? -1 : 0, ret.push([operation, change.value]);
        return ret
    }
    exports.__esModule = !0, exports.convertChangesToDMP = convertChangesToDMP
}, function(module, exports) {
    "use strict";

    function convertChangesToXML(changes) {
        for (var ret = [], i = 0; i < changes.length; i++) {
            var change = changes[i];
            change.added ? ret.push("<ins>") : change.removed && ret.push("<del>"), ret.push(escapeHTML(change.value)), change.added ? ret.push("</ins>") : change.removed && ret.push("</del>");

        }
        return ret.join("")
    }

    function escapeHTML(s) {
        var n = s;
        return n = n.replace(/&/g, "&amp;"), n = n.replace(/</g, "&lt;"), n = n.replace(/>/g, "&gt;"), n = n.replace(/"/g, "&quot;")
    }
    exports.__esModule = !0, exports.convertChangesToXML = convertChangesToXML
}, function(module) {
    ! function() {
        function levenshtein(a, b) {
            if (0 == a.length) return b.length;
            if (0 == b.length) return a.length;
            var i, matrix = [];
            for (i = 0; i <= b.length; i++) matrix[i] = [i];
            var j;
            for (j = 0; j <= a.length; j++) matrix[0][j] = j;
            for (i = 1; i <= b.length; i++)
                for (j = 1; j <= a.length; j++) matrix[i][j] = b.charAt(i - 1) == a.charAt(j - 1) ? matrix[i - 1][j - 1] : Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
            return matrix[b.length][a.length]
        }
        var Rematch = {};
        Rematch.arrayToString = function arrayToString(a) {
            return "[object Array]" === Object.prototype.toString.apply(a, []) ? "[" + a.map(arrayToString).join(", ") + "]" : a
        }, Rematch.levenshtein = levenshtein, Rematch.distance = function(x, y) {
            x = x.trim(), y = y.trim();
            var lev = levenshtein(x, y),
                score = lev / (x.length + y.length);
            return score
        }, Rematch.rematch = function(distanceFunction) {
            function findBestMatch(a, b, cache) {
                var cachecount = 0;
                for (var key in cache) cachecount++;
                for (var bestMatch, bestMatchDist = 1 / 0, i = 0; i < a.length; ++i)
                    for (var j = 0; j < b.length; ++j) {
                        var md, cacheKey = JSON.stringify([a[i], b[j]]);
                        cache.hasOwnProperty(cacheKey) ? md = cache[cacheKey] : (md = distanceFunction(a[i], b[j]), cache[cacheKey] = md), bestMatchDist > md && (bestMatchDist = md, bestMatch = {
                            indexA: i,
                            indexB: j,
                            score: bestMatchDist
                        })
                    }
                return bestMatch
            }

            function group(a, b, level, cache) {
                "undefined" == typeof cache && (cache = {});
                var bm = findBestMatch(a, b, cache);
                if (level || (level = 0), !bm || a.length + b.length < 3) return [
                    [a, b]
                ];
                var a1 = a.slice(0, bm.indexA),
                    b1 = b.slice(0, bm.indexB),
                    aMatch = [a[bm.indexA]],
                    bMatch = [b[bm.indexB]],
                    tailA = bm.indexA + 1,
                    tailB = bm.indexB + 1,
                    a2 = a.slice(tailA),
                    b2 = b.slice(tailB),
                    group1 = group(a1, b1, level + 1, cache),
                    groupMatch = group(aMatch, bMatch, level + 1, cache),
                    group2 = group(a2, b2, level + 1, cache),
                    result = groupMatch;
                return (bm.indexA > 0 || bm.indexB > 0) && (result = group1.concat(result)), (a.length > tailA || b.length > tailB) && (result = result.concat(group2)), result
            }
            return group
        }, module.exports.Rematch = Rematch
    }()
}, function(module, exports, __webpack_require__) {
    ! function() {
        function HtmlPrinter() {}
        var LineByLinePrinter = __webpack_require__(22).LineByLinePrinter,
            sideBySidePrinter = __webpack_require__(23).SideBySidePrinter;
        HtmlPrinter.prototype.generateLineByLineJsonHtml = function(diffFiles, config) {
            var lineByLinePrinter = new LineByLinePrinter(config);
            return lineByLinePrinter.generateLineByLineJsonHtml(diffFiles)
        }, HtmlPrinter.prototype.generateSideBySideJsonHtml = sideBySidePrinter.generateSideBySideJsonHtml, module.exports.HtmlPrinter = new HtmlPrinter
    }()
}, function(module, exports, __webpack_require__) {
    ! function() {
        function LineByLinePrinter(config) {
            this.config = config
        }
        var diffParser = __webpack_require__(1).DiffParser,
            printerUtils = __webpack_require__(4).PrinterUtils,
            utils = __webpack_require__(2).Utils,
            Rematch = __webpack_require__(20).Rematch;
        LineByLinePrinter.prototype.generateLineByLineJsonHtml = function(diffFiles) {
            var that = this;
            return '<div class="d2h-wrapper">\n' + diffFiles.map(function(file) {
                var diffs;
                return diffs = file.blocks.length ? that._generateFileHtml(file) : that._generateEmptyDiff(), '<div id="' + printerUtils.getHtmlId(file) + '" class="d2h-file-wrapper" data-lang="' + file.language + '">\n     <div class="d2h-file-header">\n       <div class="d2h-file-stats">\n         <span class="d2h-lines-added">           <span>+' + file.addedLines + '</span>\n         </span>\n         <span class="d2h-lines-deleted">           <span>-' + file.deletedLines + '</span>\n         </span>\n       </div>\n       <div class="d2h-file-name">' + printerUtils.getDiffName(file) + '</div>\n     </div>\n     <div class="d2h-file-diff">\n       <div class="d2h-code-wrapper">\n         <table class="d2h-diff-table">\n           <tbody class="d2h-diff-tbody">\n         ' + diffs + "           </tbody>\n         </table>\n       </div>\n     </div>\n   </div>\n"
            }).join("\n") + "</div>\n"
        };
        var matcher = Rematch.rematch(function(a, b) {
            var amod = a.content.substr(1),
                bmod = b.content.substr(1);
            return Rematch.distance(amod, bmod)
        });
        LineByLinePrinter.prototype._generateFileHtml = function(file) {
            var that = this;
            return file.blocks.map(function(block) {
                function processChangeBlock() {
                    var matches, insertType, deleteType, doMatching = "lines" === that.config.matching || "words" === that.config.matching;
                    doMatching ? (matches = matcher(oldLines, newLines), insertType = diffParser.LINE_TYPE.INSERT_CHANGES, deleteType = diffParser.LINE_TYPE.DELETE_CHANGES) : (matches = [
                        [oldLines, newLines]
                    ], insertType = diffParser.LINE_TYPE.INSERTS, deleteType = diffParser.LINE_TYPE.DELETES), matches.forEach(function(match) {
                        oldLines = match[0], newLines = match[1];
                        for (var oldLine, newLine, processedOldLines = [], processedNewLines = [], common = Math.min(oldLines.length, newLines.length), j = 0; common > j; j++) {
                            oldLine = oldLines[j], newLine = newLines[j], that.config.isCombined = file.isCombined;
                            var diff = printerUtils.diffHighlight(oldLine.content, newLine.content, that.config);
                            processedOldLines += that._generateLineHtml(deleteType, oldLine.oldNumber, oldLine.newNumber, diff.first.line, diff.first.prefix), processedNewLines += that._generateLineHtml(insertType, newLine.oldNumber, newLine.newNumber, diff.second.line, diff.second.prefix)
                        }
                        lines += processedOldLines + processedNewLines, lines += that._processLines(oldLines.slice(common), newLines.slice(common))
                    }), oldLines = [], newLines = []
                }
                for (var lines = '<tr>\n  <td class="d2h-code-linenumber ' + diffParser.LINE_TYPE.INFO + '"></td>\n  <td class="' + diffParser.LINE_TYPE.INFO + '">    <div class="d2h-code-line ' + diffParser.LINE_TYPE.INFO + '">' + utils.escape(block.header) + "</div>  </td>\n</tr>\n", oldLines = [], newLines = [], i = 0; i < block.lines.length; i++) {
                    var line = block.lines[i],
                        escapedLine = utils.escape(line.content);
                    line.type !== diffParser.LINE_TYPE.INSERTS && (newLines.length > 0 || line.type !== diffParser.LINE_TYPE.DELETES && oldLines.length > 0) && processChangeBlock(), line.type === diffParser.LINE_TYPE.CONTEXT ? lines += that._generateLineHtml(line.type, line.oldNumber, line.newNumber, escapedLine) : line.type !== diffParser.LINE_TYPE.INSERTS || oldLines.length ? line.type === diffParser.LINE_TYPE.DELETES ? oldLines.push(line) : line.type === diffParser.LINE_TYPE.INSERTS && Boolean(oldLines.length) ? newLines.push(line) : (console.error("Unknown state in html line-by-line generator"), processChangeBlock()) : lines += that._generateLineHtml(line.type, line.oldNumber, line.newNumber, escapedLine)
                }
                return processChangeBlock(), lines
            }).join("\n")
        }, LineByLinePrinter.prototype._processLines = function(oldLines, newLines) {
            for (var lines = "", i = 0; i < oldLines.length; i++) {
                var oldLine = oldLines[i],
                    oldEscapedLine = utils.escape(oldLine.content);
                lines += this._generateLineHtml(oldLine.type, oldLine.oldNumber, oldLine.newNumber, oldEscapedLine)
            }
            for (var j = 0; j < newLines.length; j++) {
                var newLine = newLines[j],
                    newEscapedLine = utils.escape(newLine.content);
                lines += this._generateLineHtml(newLine.type, newLine.oldNumber, newLine.newNumber, newEscapedLine)
            }
            return lines
        }, LineByLinePrinter.prototype._generateLineHtml = function(type, oldNumber, newNumber, content, prefix) {
            var htmlPrefix = "";
            prefix && (htmlPrefix = '<span class="d2h-code-line-prefix">' + prefix + "</span>");
            var htmlContent = "";
            return content && (htmlContent = '<span class="d2h-code-line-ctn">' + content + "</span>"), '<tr>\n  <td class="d2h-code-linenumber ' + type + '">    <div class="line-num1">' + utils.valueOrEmpty(oldNumber) + '</div>    <div class="line-num2">' + utils.valueOrEmpty(newNumber) + '</div>  </td>\n  <td class="' + type + '">    <div class="d2h-code-line ' + type + '">' + htmlPrefix + htmlContent + "</div>  </td>\n</tr>\n"
        }, LineByLinePrinter.prototype._generateEmptyDiff = function() {
            return '<tr>\n  <td class="' + diffParser.LINE_TYPE.INFO + '">    <div class="d2h-code-line ' + diffParser.LINE_TYPE.INFO + '">File without changes    </div>  </td>\n</tr>\n'
        }, module.exports.LineByLinePrinter = LineByLinePrinter
    }()
}, function(module, exports, __webpack_require__) {
    ! function() {
        function SideBySidePrinter() {}

        function generateSideBySideFileHtml(file, config) {
            var fileHtml = {};
            return fileHtml.left = "", fileHtml.right = "", file.blocks.forEach(function(block) {
                function processChangeBlock() {
                    var matches, insertType, deleteType, doMatching = "lines" === config.matching || "words" === config.matching;
                    doMatching ? (matches = matcher(oldLines, newLines), insertType = diffParser.LINE_TYPE.INSERT_CHANGES, deleteType = diffParser.LINE_TYPE.DELETE_CHANGES) : (matches = [
                        [oldLines, newLines]
                    ], insertType = diffParser.LINE_TYPE.INSERTS, deleteType = diffParser.LINE_TYPE.DELETES), matches.forEach(function(match) {
                        oldLines = match[0], newLines = match[1];
                        for (var common = Math.min(oldLines.length, newLines.length), max = Math.max(oldLines.length, newLines.length), j = 0; common > j; j++) {
                            var oldLine = oldLines[j],
                                newLine = newLines[j];
                            config.isCombined = file.isCombined;
                            var diff = printerUtils.diffHighlight(oldLine.content, newLine.content, config);
                            fileHtml.left += generateSingleLineHtml(deleteType, oldLine.oldNumber, diff.first.line, diff.first.prefix), fileHtml.right += generateSingleLineHtml(insertType, newLine.newNumber, diff.second.line, diff.second.prefix)
                        }
                        if (max > common) {
                            var oldSlice = oldLines.slice(common),
                                newSlice = newLines.slice(common),
                                tmpHtml = processLines(oldSlice, newSlice);
                            fileHtml.left += tmpHtml.left, fileHtml.right += tmpHtml.right
                        }
                    }), oldLines = [], newLines = []
                }
                fileHtml.left += '<tr>\n  <td class="d2h-code-side-linenumber ' + diffParser.LINE_TYPE.INFO + '"></td>\n  <td class="' + diffParser.LINE_TYPE.INFO + '">    <div class="d2h-code-side-line ' + diffParser.LINE_TYPE.INFO + '">      ' + utils.escape(block.header) + "    </div>  </td>\n</tr>\n", fileHtml.right += '<tr>\n  <td class="d2h-code-side-linenumber ' + diffParser.LINE_TYPE.INFO + '"></td>\n  <td class="' + diffParser.LINE_TYPE.INFO + '">    <div class="d2h-code-side-line ' + diffParser.LINE_TYPE.INFO + '"></div>  </td>\n</tr>\n';
                for (var oldLines = [], newLines = [], i = 0; i < block.lines.length; i++) {
                    var line = block.lines[i],
                        prefix = line[0],
                        escapedLine = utils.escape(line.content.substr(1));
                    line.type !== diffParser.LINE_TYPE.INSERTS && (newLines.length > 0 || line.type !== diffParser.LINE_TYPE.DELETES && oldLines.length > 0) && processChangeBlock(), line.type === diffParser.LINE_TYPE.CONTEXT ? (fileHtml.left += generateSingleLineHtml(line.type, line.oldNumber, escapedLine, prefix), fileHtml.right += generateSingleLineHtml(line.type, line.newNumber, escapedLine, prefix)) : line.type !== diffParser.LINE_TYPE.INSERTS || oldLines.length ? line.type === diffParser.LINE_TYPE.DELETES ? oldLines.push(line) : line.type === diffParser.LINE_TYPE.INSERTS && Boolean(oldLines.length) ? newLines.push(line) : (console.error("unknown state in html side-by-side generator"), processChangeBlock()) : (fileHtml.left += generateSingleLineHtml(diffParser.LINE_TYPE.CONTEXT, "", "", ""), fileHtml.right += generateSingleLineHtml(line.type, line.newNumber, escapedLine, prefix))
                }
                processChangeBlock()
            }), fileHtml
        }

        function processLines(oldLines, newLines) {
            var fileHtml = {};
            fileHtml.left = "", fileHtml.right = "";
            for (var maxLinesNumber = Math.max(oldLines.length, newLines.length), i = 0; maxLinesNumber > i; i++) {
                var oldContent, newContent, oldPrefix, newPrefix, oldLine = oldLines[i],
                    newLine = newLines[i];
                oldLine && (oldContent = utils.escape(oldLine.content.substr(1)), oldPrefix = oldLine.content[0]), newLine && (newContent = utils.escape(newLine.content.substr(1)), newPrefix = newLine.content[0]), oldLine && newLine ? (fileHtml.left += generateSingleLineHtml(oldLine.type, oldLine.oldNumber, oldContent, oldPrefix), fileHtml.right += generateSingleLineHtml(newLine.type, newLine.newNumber, newContent, newPrefix)) : oldLine ? (fileHtml.left += generateSingleLineHtml(oldLine.type, oldLine.oldNumber, oldContent, oldPrefix), fileHtml.right += generateSingleLineHtml(diffParser.LINE_TYPE.CONTEXT, "", "", "")) : newLine ? (fileHtml.left += generateSingleLineHtml(diffParser.LINE_TYPE.CONTEXT, "", "", ""), fileHtml.right += generateSingleLineHtml(newLine.type, newLine.newNumber, newContent, newPrefix)) : console.error("How did it get here?")
            }
            return fileHtml
        }

        function generateSingleLineHtml(type, number, content, prefix) {
            var htmlPrefix = "";
            prefix && (htmlPrefix = '<span class="d2h-code-line-prefix">' + prefix + "</span>");
            var htmlContent = "";
            return content && (htmlContent = '<span class="d2h-code-line-ctn">' + content + "</span>"), '<tr>\n    <td class="d2h-code-side-linenumber ' + type + '">' + number + '</td>\n    <td class="' + type + '">      <div class="d2h-code-side-line ' + type + '">' + htmlPrefix + htmlContent + "</div>    </td>\n  </tr>\n"
        }

        function generateEmptyDiff() {
            var fileHtml = {};
            return fileHtml.right = "", fileHtml.left = '<tr>\n  <td class="' + diffParser.LINE_TYPE.INFO + '">    <div class="d2h-code-side-line ' + diffParser.LINE_TYPE.INFO + '">File without changes    </div>  </td>\n</tr>\n', fileHtml
        }
        var diffParser = __webpack_require__(1).DiffParser,
            printerUtils = __webpack_require__(4).PrinterUtils,
            utils = __webpack_require__(2).Utils,
            Rematch = __webpack_require__(20).Rematch;
        SideBySidePrinter.prototype.generateSideBySideJsonHtml = function(diffFiles, config) {
            return '<div class="d2h-wrapper">\n' + diffFiles.map(function(file) {
                var diffs;
                return diffs = file.blocks.length ? generateSideBySideFileHtml(file, config) : generateEmptyDiff(), '<div id="' + printerUtils.getHtmlId(file) + '" class="d2h-file-wrapper" data-lang="' + file.language + '">\n     <div class="d2h-file-header">\n       <div class="d2h-file-stats">\n         <span class="d2h-lines-added">           <span>+' + file.addedLines + '</span>\n         </span>\n         <span class="d2h-lines-deleted">           <span>-' + file.deletedLines + '</span>\n         </span>\n       </div>\n       <div class="d2h-file-name">' + printerUtils.getDiffName(file) + '</div>\n     </div>\n     <div class="d2h-files-diff">\n       <div class="d2h-file-side-diff">\n         <div class="d2h-code-wrapper">\n           <table class="d2h-diff-table">\n             <tbody class="d2h-diff-tbody">\n           ' + diffs.left + '             </tbody>\n           </table>\n         </div>\n       </div>\n       <div class="d2h-file-side-diff">\n         <div class="d2h-code-wrapper">\n           <table class="d2h-diff-table">\n             <tbody class="d2h-diff-tbody">\n           ' + diffs.right + "             </tbody>\n           </table>\n         </div>\n       </div>\n     </div>\n   </div>\n"
            }).join("\n") + "</div>\n"
        };
        var matcher = Rematch.rematch(function(a, b) {
            var amod = a.content.substr(1),
                bmod = b.content.substr(1);
            return Rematch.distance(amod, bmod)
        });
        module.exports.SideBySidePrinter = new SideBySidePrinter
    }()
}]);
